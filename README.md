# Sudoku Solver
A simple Sudoku solver that automatically searches for a feasible solution of a Grid.
Note that if more than a solution is available for a certain Grid, only one of them is computed.

The solver leverages 2 basic A.I. heuristics known as **Most Contrained Variable** and **Least Constraining Value**.

In order to revert all the choices taken up to a certain branch, the solver makes use of a simple **checkpointing system**.

## Build
Download or clone the repository:
``` bash
git clone https://github.com/kristopher-pellizzi/SudokuSolver
```

cd into the root folder of the repository and launch the *make* command:
```bash
make
```

The command will compile all the source files and generate the executable *solver* into the root of the repository.

## Clean
The provided *makefile* allows to easily remove all files generated during the compilation and building stages.

cd into the root folder of the repository and launch the following *make* command:
``` bash
make clean
```
This command will effectively remove all object and executable files generated by the compilation and linking process.

## Most Constrained Variable (MCV)
Also known as **Minimum Remaining Values**.

The Sudoku solver leverages this heuristic during the **Cell Selection Phase**.
In this phase, the solver selects a cell to be filled.

A ***basic*** way to perform this stage would be select the first empty cell, or a random empty cell.

This way, however, the solver may select a cell with just a few constraints, and therefore with many possible values available.
In the worst case, we may need to make an attempt with every single available value for that cell.

Moreover, by selecting a value for a less constrained cell, we may constrain even more some other cell in the grid, thus possibly leading to unfeasible solutions that would have been discovered faster if we selected the other cell first.
So, in the **Cell Selection Phase**, the solver will select one of the cells with more constraints.

First, it will always select a cell that has only 1 possible value available.
In case there is none, the cell with the fewest number of possible values is selected.
The first detected one is selected in case of a tie.

More information about MCV is available [here](https://stanford.edu/~shervine/teaching/cs-221/cheatsheet-variables-models#dynamic-ordering).

## Least Contraining Value (LCV)
The Sudoku solver leverages this heuristic during the **Value Selection Phase**.

In this phase, the solver has already selected a cell, and it must now choose a value to be assigned.

A ***basic*** way to perform this stage would be select the first available value, or a random one.

This way, however, the solver may select a value that heavily constrain other cells, thus leading to unfeasible solutions.

So, in the **Value Selection Phase**, the solver selects one of the available values that reduces the constraints applied to other cells.

Indeed, in the game of Sudoku, when we assign a value to a cell, we are removing that value from the set of possible values for all the cells in the same row, in the same column and in the same block, that we'll refer to as *Neighbour Cells*.

In practice, the application of this heuristic allows the solver to always choose a value so that keeps as high as possible the number of possible values for Neighbour Cells.

Ideally, this means that the solver is selecting the value that has the lowest probability of making Grid completion infeasible.

More information about LCV is available [here](https://stanford.edu/~shervine/teaching/cs-221/cheatsheet-variables-models#dynamic-ordering).

## Checkpointing System
The solution of a **Constraint Satisfaction Problem** (CSP) like finding the solution of a Sudoku Grid requires to explore a search tree whose branches represent a choice that is taken while searching for the solution.

Therefore, thoretically, each state is represented as a node of the search tree, and each choice generates a branch of the tree.

Whenever we reach a state that does not allow to find a feasible solution (e.g. the selected cell has no available values), we need to **rollback** to a previous choice and make a new choice that generates a new branch that leads either to a solution or to another unfeasible state.

In order to implement rollbacks, the solver makes use of a simple **checkpointing system** that allows to create a *checkpoint* (i.e. a copy of the current state) and to store it in a stack.

If the solver reaches an unfeasible state, it can pop the last stored checkpoint from the stack and make a new choice to keep exploring the search tree from there.

### Branch Pruning
In some cases, it is possible to detect ahead of time that a choice is going to lead to an unfeasible state.

For instance, if we choose a value for a cell and one of its Neighbour Cells has that value as the only available value, there's no point in proceeding with this choice.

In order to reach a feasible solution faster, the solver implements some checks that allow to avoid making useless choices, thus avoiding exploring branches of the search tree that lead to an unfeasible state.

### Checkpoints Optimizations
In some cases, there's no need to generate a checkpoint and push it to the checkpoint stack.

For instance, if a cell has only 1 value available, there's no point in creating a checkpoint when we choose that value.

Indeed, if we did, we would come back to a state where the selected cell has no more available values, and therefore we would need to restore another checkpoint.

So, the solver simply avoids creating a checkpoint when a cell has only 1 value available, so that, in case of rollback, the state comes back to a point where a new choice is possible.

Analogously, no checkpoint is created when a cell with only 1 possible value is selected in the **Cell Selection Phase**.

In this cases, the cell has only 1 admissible choice. 

If the value it requires leads to an unfeasible state, rollbacking to a state where we select another cell instead of that one would only lead to useless exploration.
Indeed, there are only 2 possible cases:
1) The assignment of another cell will remove the only possible value for that cell, thus leading to an unfeasible state
2) The only possible value is not removed from the cell. However, the solver already tried that value, and it led to an unfeasible state. Choosing the same value for the same cell in a different moment would not lead to a different outcome.

So, everytime a cell with a single available value is selected and a rollback is needed, the solver pops a checkpoint from the stack that restores the state to a choice preceding the selection of that cell, so that it is possible to perform a new choice that will hopefully lead to a different outcome.